# -*- coding: utf-8 -*-
"""Medical Image Triage Assistant

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a-DaSwyTIVpHrugM4-3iD72lN-5X1nEi
"""

# =========================
# src/dataset.py
# =========================
from pathlib import Path
from PIL import Image
import torch
from torch.utils.data import Dataset
import torchvision.transforms as T

class SimpleImageDataset(Dataset):
    def __init__(self, folder: Path, transform=None, ext=("png","jpg","jpeg")):
        self.files = [p for p in sorted(folder.glob("*")) if p.suffix.lower().lstrip(".") in ext]
        self.transform = transform or T.Compose([T.Resize((224,224)), T.ToTensor()])
    def __len__(self):
        return len(self.files)
    def __getitem__(self, idx):
        p = self.files[idx]
        img = Image.open(p).convert("RGB")
        img = self.transform(img)
        return img, str(p.name)

# =========================
# src/model.py
# =========================
import torch.nn as nn
import torch.nn.functional as F

class SimpleCNN(nn.Module):
    def __init__(self, n_classes=2):
        super().__init__()
        self.conv1 = nn.Conv2d(3,32,3,padding=1)
        self.conv2 = nn.Conv2d(32,64,3,padding=1)
        self.conv3 = nn.Conv2d(64,128,3,padding=1)
        self.pool = nn.MaxPool2d(2)
        self.fc1 = nn.Linear(128*28*28, 256)
        self.fc2 = nn.Linear(256, n_classes)
    def forward(self, x):
        x = F.relu(self.conv1(x)); x = self.pool(x)
        x = F.relu(self.conv2(x)); x = self.pool(x)
        x = F.relu(self.conv3(x)); x = self.pool(x)
        x = x.view(x.size(0), -1)
        x = F.relu(self.fc1(x))
        return self.fc2(x)

# =========================
# src/train.py
# =========================
import torch
from torch.utils.data import DataLoader
from pathlib import Path
import torch.optim as optim
import torch.nn as nn
from dataset import SimpleImageDataset
from model import SimpleCNN
import argparse
import pandas as pd

def train(data_folder: Path, out_model: Path, epochs=5, batch_size=8, lr=1e-3, device="cpu"):
    ds = SimpleImageDataset(data_folder)
    dl = DataLoader(ds, batch_size=batch_size, shuffle=True)
    model = SimpleCNN(n_classes=2).to(device)
    opt = optim.Adam(model.parameters(), lr=lr)
    crit = nn.CrossEntropyLoss()
    model.train()
    for ep in range(epochs):
        total_loss = 0.0
        for xb, names in dl:
            xb = xb.to(device)
            # NOTE: this template assumes labeled data not provided.
            # For demonstration we use dummy labels=0; replace with real labels in production.
            y = torch.zeros(xb.size(0), dtype=torch.long, device=device)
            opt.zero_grad()
            logits = model(xb)
            loss = crit(logits, y)
            loss.backward()
            opt.step()
            total_loss += loss.item()
        print(f"Epoch {ep+1}/{epochs}: loss={total_loss/len(dl):.4f}")
    out_model.parent.mkdir(parents=True, exist_ok=True)
    torch.save(model.state_dict(), out_model)
    print(f"Saved model to {out_model}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--data", required=True)
    parser.add_argument("--out", default="models/triage_cnn.pth")
    parser.add_argument("--epochs", type=int, default=3)
    parser.add_argument("--batch", type=int, default=8)
    args = parser.parse_args()
    train(Path(args.data), Path(args.out), epochs=args.epochs, batch_size=args.batch)

# =========================
# src/infer.py
# =========================
import torch
from pathlib import Path
from dataset import SimpleImageDataset
from model import SimpleCNN
from torch.utils.data import DataLoader
import argparse
import pandas as pd
import torch.nn.functional as F

def infer(model_path: Path, data_folder: Path, out_csv: Path, device="cpu", threshold=0.5):
    ds = SimpleImageDataset(data_folder)
    dl = DataLoader(ds, batch_size=8)
    model = SimpleCNN(n_classes=2)
    model.load_state_dict(torch.load(model_path, map_location=device))
    model.to(device).eval()
    rows = []
    with torch.no_grad():
        for xb, names in dl:
            xb = xb.to(device)
            logits = model(xb)
            probs = F.softmax(logits, dim=1)[:,1].cpu().numpy()  # prob of abnormal class
            for name, p in zip(names, probs):
                rows.append({"image": name, "abnormal_prob": float(p), "flag": int(p>=threshold)})
    pd.DataFrame(rows).to_csv(out_csv, index=False)
    print(f"Wrote inference results to {out_csv}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--model", required=True)
    parser.add_argument("--data", required=True)
    parser.add_argument("--out", default="results/infer.csv")
    parser.add_argument("--threshold", type=float, default=0.5)
    args = parser.parse_args()
    infer(Path(args.model), Path(args.data), Path(args.out), threshold=args.threshold)